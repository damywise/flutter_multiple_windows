# Flutter Multi-Window Title Bar Manipulation

## Overview

This document describes a comprehensive implementation for hiding and showing title bars in Flutter's multi-window system on Windows. The solution addresses the challenges of manipulating window chrome in Flutter applications while maintaining compatibility with Flutter's window management architecture.

## Problem Statement

### Original Challenge
- Flutter's multi-window system creates windows with standard title bars
- No built-in API to hide/show title bars programmatically
- Need for custom window chrome manipulation without breaking Flutter's window management
- Compatibility requirements with Flutter's multi-window architecture

### Key Requirements
- ✅ Hide/show title bars on demand
- ✅ Work with Flutter's multi-window system
- ✅ Proper window resizing and frame calculations
- ✅ Integration with Flutter's MethodChannel system
- ✅ Windows-specific implementation using native APIs

## Solution Architecture

### Approach Overview

The implementation uses a **hybrid approach** combining:
1. **Flutter MethodChannel** for communication between Dart and native code
2. **Window Subclassing** for intercepting Windows messages
3. **DWM API** for proper Desktop Window Manager integration
4. **Window State Tracking** to manage multiple Flutter windows

### Architecture Diagram

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Flutter UI    │    │  MethodChannel   │    │  Native C++     │
│   (Dart)        │◄──►│  Communication   │◄──►│  Window APIs    │
│                 │    │                  │    │                 │
│ • Button clicks │    │ • setupWindowInt │    │ • SetWindowSub  │
│ • State queries │    │ • toggleTitleBar │    │ • DWM APIs      │
│ • Error handling│    │ • getWindowInfo  │    │ • Message hooks │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │
                              ▼
                       ┌──────────────────┐
                       │  Windows APIs    │
                       │                  │
                       │ • User32.dll     │
                       │ • Dwmapi.dll     │
                       │ • Message hooks  │
                       └──────────────────┘
```

## Technical Implementation

### 1. Flutter Integration (Dart)

#### MethodChannel Setup
```dart
// lib/app/window_service.dart
class WindowService {
  static const MethodChannel _channel = MethodChannel('com.example.window_service');

  /// Toggles the title bar for a window (HWND).
  static Future<bool> toggleTitleBar(int hwnd) async {
    final bool? success = await _channel.invokeMethod('toggleTitleBar', {
      'hwnd': hwnd,
    });
    return success ?? false;
  }

  /// Sets up message interception for a specific window.
  static Future<bool> setupWindowInterception(int hwnd) async {
    final bool? success = await _channel.invokeMethod('setupWindowInterception', {
      'hwnd': hwnd,
    });
    return success ?? false;
  }
}
```

#### UI Integration
```dart
// lib/app/main_window.dart
OutlinedButton(
  onPressed: () async {
    final focusedHwnd = await WindowService.getFocusedFlutterWindowHandle();
    if (focusedHwnd == null) return;

    // Set up window interception first
    await WindowService.setupWindowInterception(focusedHwnd);

    // Toggle title bar
    final success = await WindowService.toggleTitleBar(focusedHwnd);
    // Handle result...
  },
  child: const Text('Toggle Focused Window Title Bar'),
)
```

### 2. Native Implementation (C++)

#### Window Subclassing Setup
```cpp
// Global state for tracking Flutter windows
std::map<HWND, bool> g_flutter_hidden_title_bar_windows;
std::map<HWND, WNDPROC> g_original_window_procedures;

// Forward declaration
LRESULT CALLBACK FlutterWindowSubclassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

bool setupWindowInterception(HWND hwnd) {
  // Set up window subclassing for proper message interception
  WNDPROC originalProc = reinterpret_cast<WNDPROC>(GetWindowLongPtr(hwnd, GWLP_WNDPROC));
  g_original_window_procedures[hwnd] = originalProc;

  if (SetWindowSubclass(hwnd, FlutterWindowSubclassProc, 1, 0)) {
    return true;
  }
  return false;
}
```

#### Message Interception
```cpp
LRESULT CALLBACK FlutterWindowSubclassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData) {
  // Check if this window has a hidden title bar
  auto it = g_flutter_hidden_title_bar_windows.find(hwnd);
  if (it != g_flutter_hidden_title_bar_windows.end() && it->second) {
    if (message == WM_NCCALCSIZE && wParam) {
      // Handle frame calculations for hidden title bar
      NCCALCSIZE_PARAMS* sz = reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam);

      if (::IsZoomed(hwnd)) {
        // Maximized window adjustments
        sz->rgrc[0].left += 8; sz->rgrc[0].top += 8;
        sz->rgrc[0].right -= 8; sz->rgrc[0].bottom -= 8;
      } else {
        // Normal window: extend client area into title bar
        sz->rgrc[0].top += 1; sz->rgrc[0].right -= 8;
        sz->rgrc[0].bottom -= 8; sz->rgrc[0].left -= -8;
      }
      return 0;
    }
  }

  // Call original window procedure for other messages
  auto origProcIt = g_original_window_procedures.find(hwnd);
  if (origProcIt != g_original_window_procedures.end()) {
    return CallWindowProc(origProcIt->second, hwnd, message, wParam, lParam);
  }

  return DefWindowProc(hwnd, message, wParam, lParam);
}
```

#### Title Bar Manipulation
```cpp
// Hide title bar using DWM API
if (title_bar_style == "hidden") {
  LONG_PTR style = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
  style &= ~(WS_CAPTION);  // Remove caption
  ::SetWindowLongPtrW(hwnd, GWL_STYLE, style);

  // Extend client area into title bar area
  MARGINS margins = {0, 0, 1, 0};  // Top margin = 1
  ::DwmExtendFrameIntoClientArea(hwnd, &margins);

  g_flutter_hidden_title_bar_windows[hwnd] = true;
} else {
  // Show title bar
  LONG_PTR style = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
  style |= (WS_CAPTION | WS_SYSMENU | WS_THICKFRAME);
  ::SetWindowLongPtrW(hwnd, GWL_STYLE, style);

  // Reset DWM frame to normal
  MARGINS margins = {0, 0, 0, 0};
  ::DwmExtendFrameIntoClientArea(hwnd, &margins);

  g_flutter_hidden_title_bar_windows.erase(hwnd);
}
```

### 3. Build Configuration

#### CMakeLists.txt Updates
```cmake
# Add Windows system libraries
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE user32 comctl32 dwmapi)
```

### 4. Key Technical Insights

#### Type Conversion Challenge
**Problem**: Dart sends integers as `int32_t` but Windows APIs expect `int64_t` for handles.
**Solution**: Explicit type checking and conversion in native code:

```cpp
// Handle different numeric types from Dart
if (std::holds_alternative<int64_t>(value)) {
  hwnd_val = std::get<int64_t>(value);
} else if (std::holds_alternative<int32_t>(value)) {
  hwnd_val = static_cast<int64_t>(std::get<int32_t>(value));
} else if (std::holds_alternative<double>(value)) {
  hwnd_val = static_cast<int64_t>(std::get<double>(value));
}
```

#### DWM Margin Technique
**Problem**: Simply removing `WS_CAPTION` doesn't properly hide the title bar area.
**Solution**: Use `DwmExtendFrameIntoClientArea` with specific margins:

```cpp
// Hidden: Extend client area into title bar
MARGINS margins = {0, 0, 1, 0};  // Top margin = 1

// Normal: Reset to standard frame
MARGINS margins = {0, 0, 0, 0};
```

#### Window Subclassing vs Global Hooks
**Problem**: Global Windows hooks can interfere with Flutter's window management.
**Solution**: Use window subclassing for specific Flutter windows only:

```cpp
// Only subclass Flutter windows
if (IsFlutterWindow(hwnd)) {
  SetWindowSubclass(hwnd, FlutterWindowSubclassProc, 1, 0);
}
```

## Implementation Details

### Flutter Window Detection
```cpp
bool IsFlutterWindow(HWND hwnd) {
  // Check window class name for Flutter patterns
  wchar_t className[256];
  if (GetClassNameW(hwnd, className, sizeof(className) / sizeof(wchar_t))) {
    std::wstring classStr(className);
    if (classStr.find(L"FLUTTER") != std::wstring::npos) {
      return true;
    }
  }

  // Verify window belongs to current process
  DWORD pid = 0;
  GetWindowThreadProcessId(hwnd, &pid);
  return (pid == GetCurrentProcessId());
}
```

### Message Flow
1. **Flutter UI** → MethodChannel call
2. **Native Handler** → Validate hwnd and parameters
3. **Window Setup** → Set up subclassing for message interception
4. **Style Manipulation** → Modify window styles and DWM frame
5. **State Tracking** → Update global state for message handling
6. **Window Redraw** → Force complete window update

### Error Handling
- **Window Validation**: Check if hwnd is valid before operations
- **Type Safety**: Handle different numeric types from Dart
- **Graceful Degradation**: Proper error responses instead of crashes
- **Cleanup**: Remove subclassing on application exit

## Usage Instructions

### Basic Usage
```dart
// Get the focused Flutter window
final hwnd = await WindowService.getFocusedFlutterWindowHandle();

// Set up window interception (required)
await WindowService.setupWindowInterception(hwnd);

// Toggle title bar
await WindowService.toggleTitleBar(hwnd);
```

### Advanced Usage
```dart
// Explicit control
await WindowService.setTitleBarStyle(hwnd, titleBarStyle: 'hidden');
await WindowService.setTitleBarStyle(hwnd, titleBarStyle: 'normal');

// Get window information
final handles = await WindowService.getFlutterWindowHandles();
final info = await WindowService.getWindowInfo(hwnd);
```

## Architecture Decisions

### Why Window Subclassing Instead of Global Hooks?

**Global Hooks (Rejected)**:
- ❌ Intercept ALL windows in process
- ❌ Can interfere with Flutter's internals
- ❌ Difficult to target specific windows
- ❌ May cause stability issues

**Window Subclassing (Chosen)**:
- ✅ Only affects specific Flutter windows
- ✅ Minimal interference with Flutter
- ✅ Precise control over message handling
- ✅ Proper integration with Windows API

### Why DWM API Instead of Simple Style Manipulation?

**Style Manipulation Only (Insufficient)**:
- ❌ Doesn't handle frame calculations properly
- ❌ Breaks window resizing behavior
- ❌ Visual artifacts during window operations

**DWM API (Proper Solution)**:
- ✅ Handles non-client area calculations
- ✅ Proper frame extension into title bar area
- ✅ Works correctly with window resizing
- ✅ Follows Windows design patterns

## Known Limitations

### Multi-Window Considerations
- Each Flutter window must be set up individually
- Window handles must be obtained from Flutter (not Windows enumeration)
- State tracking is per-window, not global

### Windows Version Compatibility
- Requires Windows Vista or later for DWM API
- Tested on Windows 10/11
- May need adjustments for older Windows versions

### Flutter Integration
- Requires hwnd from Flutter's window management
- May need updates for future Flutter versions
- Depends on Flutter's MethodChannel implementation

## Performance Considerations

### Memory Usage
- Minimal: Only tracks active Flutter windows
- Automatic cleanup on window destruction
- No persistent global state

### CPU Usage
- Message interception only for subclassed windows
- Minimal overhead for non-title bar messages
- Efficient window identification

### Build Impact
- Adds Windows system libraries to link dependencies
- No runtime performance impact on non-window operations

## Future Enhancements

### Potential Improvements
1. **Cross-Platform Support**: Extend to macOS and Linux
2. **Animation Support**: Smooth title bar hide/show transitions
3. **Theme Integration**: Respect system dark/light mode
4. **Accessibility**: Ensure proper screen reader support

### Advanced Features
1. **Custom Title Bar Content**: Replace with custom Flutter widgets
2. **Window Snapping**: Enhanced snap zones for borderless windows
3. **Multi-Monitor Support**: Proper handling across multiple displays

## Troubleshooting

### Common Issues
1. **"Invalid window handle"**: Ensure hwnd is obtained from Flutter, not Windows enumeration
2. **"Failed to set up window interception"**: Window may not be a valid Flutter window
3. **Visual artifacts**: May need window redraw after title bar changes

### Debug Information
- Check console output for detailed logging
- Verify window handles are valid Flutter windows
- Ensure proper cleanup on application exit

## Recent Improvements

### Frameless Window Support
**New Feature Added**: Complete frameless window functionality for Flutter multi-window applications, following the window_manager plugin's approach exactly.

**Implementation Details**:
- **Complete Border Removal**: Removes ALL window styles that create visual borders and corners
- **DWM Attribute Control**: Disables window shadows and corner rounding for clean appearance
- **Extended Style Management**: Removes all extended styles that create visual effects
- **Message Handler Integration**: `WM_NCCALCSIZE` handler supports frameless mode with proper calculations

**Complete Style Removal**:
- **Window Styles**: `WS_CAPTION`, `WS_THICKFRAME`, `WS_SYSMENU`, `WS_MINIMIZEBOX`, `WS_MAXIMIZEBOX`, `WS_BORDER`, `WS_DLGFRAME`, `WS_SIZEBOX`
- **Extended Styles**: `WS_EX_WINDOWEDGE`, `WS_EX_CLIENTEDGE`, `WS_EX_DLGMODALFRAME`, `WS_EX_STATICEDGE`, `WS_EX_TOOLWINDOW`, `WS_EX_APPWINDOW`
- **DWM Attributes**: Disables window shadows and corner rounding

**Key Methods Added**:
- `toggleFrameless(hwnd)` - Smart toggle between normal and frameless modes
- `setFrameless(hwnd, frameless)` - Explicit frameless mode control

**Code Changes**:
```cpp
// Complete style removal for frameless windows
style &= ~(WS_CAPTION | WS_THICKFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
          WS_BORDER | WS_DLGFRAME | WS_SIZEBOX);
style |= WS_THICKFRAME;  // Keep resizing capability

// Remove ALL extended styles
exStyle &= ~(WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE | WS_EX_DLGMODALFRAME |
            WS_EX_STATICEDGE | WS_EX_TOOLWINDOW | WS_EX_APPWINDOW);

// Disable DWM visual effects
DWM_WINDOW_CORNER_PREFERENCE cornerPref = DWMWCP_DONOTROUND;
::DwmSetWindowAttribute(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &cornerPref, sizeof(cornerPref));
::DwmSetWindowAttribute(hwnd, DWMWA_NCRENDERING_ENABLED, &noShadow, sizeof(noShadow));
```

### Borderless Window Enhancement
**Issue Identified**: Windows with hidden title bars showed visible borders on all sides, including a white line artifact on Windows 10.

**Root Cause**: The `WM_NCCALCSIZE` message handler wasn't properly removing all standard Windows borders and didn't account for Windows version differences.

**Solution Implemented**:
- **Windows Version Detection**: Added `IsWindows11OrGreater()` function to handle OS-specific behavior
- **Complete Border Removal**: Remove 8px borders from all sides: `right -= 8`, `bottom -= 8`, `left -= -8`
- **Windows 10 Fix**: Add 1px to top border to prevent white line artifact
- **Windows 11 Optimization**: No top border adjustment needed

**Code Changes**:
```cpp
// Windows version-aware border handling
sz->rgrc[0].top += IsWindows11OrGreater() ? 0 : 1;  // Windows 10 vs 11

// Remove all standard Windows borders (8px each side)
sz->rgrc[0].right -= 8;   // Remove right border
sz->rgrc[0].bottom -= 8;  // Remove bottom border
sz->rgrc[0].left -= -8;   // Remove left border
```

## Conclusion

This implementation provides a robust solution for title bar manipulation in Flutter's multi-window system. By combining Flutter's MethodChannel system with Windows-specific APIs and proper window subclassing, we achieve:

- ✅ **Complete title bar control** for Flutter windows
- ✅ **Multi-window compatibility** without interfering with Flutter
- ✅ **Proper Windows integration** using established patterns
- ✅ **Maintainable architecture** with clear separation of concerns

The solution demonstrates how to bridge Flutter's high-level UI framework with low-level Windows APIs while maintaining compatibility and stability.
